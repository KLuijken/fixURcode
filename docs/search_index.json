[
["index.html", "fixURcode 1 eat(), sleep(), debug(), repeat()", " fixURcode Anna Lohmann 2020-06-12 1 eat(), sleep(), debug(), repeat() "],
["error-messages.html", "2 Error messages 2.1 Read the error message 2.2 Google the error 2.3 Nonfuctional code but no errors", " 2 Error messages 2.1 Read the error message The very obvious first step when your code is not working: Read the error message. If that does not help. Read it again. 2.1.1 Decifer the error message Asking yourself the following question can help decifer the error message: What object is the error message referring to? What property of the object might be causing the error? Is the object … missing? … of the wrong type? … the wrong size? … wrong content? … misspelled? 2.2 Google the error Often you can also google the error. Eliminate the parts that seem unique to your own code (e.g. specific dimensions, object names,…) https://xkcd.com/979/ Pro Tip (for new or niche packages): If google won’t find the error try github. You might find the error in the package code or in a github issue. 2.3 Nonfuctional code but no errors 2.3.1 Raise warnings or messages to errors You can turn warnings and messages into errors with the foolowing code: options(warn = 2) Promote messages to errors: rlang::with_abort(f(), \"message\") 2.3.2 No visible warnings or messages If the malfunctioning code does not produce any errors or warnings check the documentation to see whether some warnings or error messages are turned off by default. Often this is some form of print = FALSE, verbose = FALSE or silent = TRUE. "],
["dont-assume-anything.html", "3 Don’t assume anything!", " 3 Don’t assume anything! Check the variable or file names. Check the object content and type. Check code that you think was working fine just a minute ago and you are certain you haven’t touched. Check whether the online example you modeled your code after actually works. Check your environment Check the function documentation, whether it really works the way you thought it would. Write a test to confirm expected behaviour. "],
["most-common-error-sources.html", "4 Most common error sources", " 4 Most common error sources In no particular order these are the most frequent reasons something goes wrong in my code: The object is of the wrong type (i.e. a matrix instead of a data.frame or the other way round) The object should have names but doesn’t. I forgot to turn of stringsaAsFactors = TRUE (Problem of the past with R 4.0). Some object does not exist (typo or silent error in earlier code). A (, {, ,, \" is missing or misplaced. I copy &amp; pasted code from the web and some weird special characters are used instead of the standard ones R would like An object from the environment is used instead of a function parameter. The object you are looking for is at a different level of a nested list. The method can’t handle missing data. A namespace conflict calls the wrong function. A package update broke some function. Tipp: When copy &amp; pasting stuff paste it in a text editor first to avoid weird non-code symbols. "],
["read-the-documentation.html", "5 Read the documentation", " 5 Read the documentation Reading documentation is a learned skill. It doesn’t come naturally and take a lot of time to master. This is not always the user’s fault. Also writing documentation is a skill that not all package developers master equally well. Try always looking for the following elements when reading documentations. What arguments does the function take? Which of those arguments have to be provided? If they don’t have to be provided is the default what I want? Which object types and dimensions should the input have? Does the input have to be named? If the documentation is unclear in these regards try inferring some of the information from examples or a package vignette. If the information on a specific package is scarce. Try the github search to see it in action. "],
["object-properties.html", "6 Object properties 6.1 The nature of an object 6.2 Object attributes 6.3 Object size 6.4 Look at objects 6.5 Compare objects", " 6 Object properties If your code does not work as expected you might want to take a closer look at certain objects and inspect their properties. The following functions come in handy: 6.1 The nature of an object str() dplyr::glimpse() class() typeof() 6.2 Object attributes names() 6.3 Object size length() dim() 6.4 Look at objects print() View() head() 6.5 Compare objects identical() "],
["check-the-function-code.html", "7 Check the function code 7.1 S3 and Debugging", " 7 Check the function code If you have consulted the documentation and the internet and still have no idea why your code is not doing what you expect it to do it can be helpful to check the function definition. You can get the code of a given function in different ways. - Click on the function name while pressing shift. - Typing an empty function call in the console There are a few things that have to be kept in mind: (1) The package containing the function has to be loaded. (2) The function you would like to explore is exported by that package. (3) It is not a generic method. can be solved by adding packagename::: in front of the function call. That way you can also explore functions that are not exported by a package. Can be solved by addding the class after of the generic function. So if you would like to explore the plot method of the bootnet package, you would have to call it as plot.bootnet() in order so see the definition. 7.1 S3 and Debugging UseMethod errors are highly uninformative The corresponding functions are called &lt;function.class&gt; or &lt;function.default&gt; Use methods() to see what methods are associated with a function or class # install.packages(&quot;bootnet&quot;) library(bootnet) bootnet::plot.bootnet() # Get everything with a print method methods(print) # Get all methods for objects of class &quot;bootnet&quot; methods(class = &quot;bootnet&quot;) Print the function code to console by calling the function without parameters and without parenthesis. bootnet::bootnet Press ctrl + left mouse click on the function name to view the function definition. If you defined the function the .R file containing the function definition will open. If the function is from a package the function code will show in a new tab. # Ctrl + mouse click opens function definition reverseLetters() bootnet::plot.bootnet() "],
["debugging-strategies.html", "8 Debugging strategies 8.1 Isolate the problem 8.2 Line-by-line debugging (Stepping through the code) 8.3 Rubber duck debugging 8.4 Print debugging 8.5 Logging", " 8 Debugging strategies 8.1 Isolate the problem 8.1.1 Minimum working example Remove as much code as possible but have the problem still occurring. Locate the source of the error. Change one thing at a time. 8.2 Line-by-line debugging (Stepping through the code) Run the code line by line Manual version of debug() 8.3 Rubber duck debugging Talk yourself through the code. (Or explain it to your rubber duck.) 8.4 Print debugging The idea of print debugging is to print certain objects or object properties close to where you expect the error might occur. Printing might show you that an object has different properties from what you would expect it to have or figure our in which iteration or with which seed something might break. This is a quick and dirty option to the more elaborate debugging tools browser() or using a break point. 8.5 Logging Similar to print debugging you might want to print a message() or cat() or use a logger to record how far your code came. Especially, when using a lot of loops it might be useful to know which iteration caused the error. "],
["debugging-tools.html", "9 Debugging tools", " 9 Debugging tools https://i.redd.it/oyov9xsfx98y.jpg RStudio comes with a number of useful build in debugging tools. You can use them in a interactive R session i.e. you can interact with your code while it is being executed. 9.0.1 Interactive R session R session reacts to user input (usually the default) Check with interactive() 9.0.2 Step through the code - debug() debug(my_defunct_function) Will open debug mode whenever my_defunct_function is called Call exported functions from a package with packagename:: Unexported functions can be referred to with packagename::: Stop debugging undebug(my_defunct_function) or overwrite the function (e.g. by sourcing it). debugonce(my_defunct_function) will go in browse mode the next time the function is called. https://www.monkeyuser.com/2017/step-by-step-debugging/ 9.0.3 browser() Enter browser() anywhere in your code where you want the execution to halt. You can then inspect the environment at that state. You can also change objects and continue. You can also use browser() as an error handler. Browse[number] The number tells you at which level of the call stack you are. options(error = recover) automatically switches to browsing when an error occurs 9.0.4 Breakpoints Does the same as browser() but without littering your code. Click left of a line number for a dot to appear. Next time you run the code it will stop there. You can explore and change the current state. [Code example from https://raw.githubusercontent.com/theavanrossum/debuggerRMarkdownLesson/master/crazify.R] 9.0.5 traceback() Shows you the last commands that have been called before the error occured (i.e. the stack). Helps locating the problem. Reverse order, latest command is on top. rlang::last_trace() is ordered in the opposite way to traceback() "],
["ask-a-peer.html", "10 Ask a peer", " 10 Ask a peer Sometimes you are so entangled in your code that you cant see the forest for the trees. What has kept you stuck for days can often be solved within minutes by a fresh pair of eyes. And even if the peer can’t sove your problem; the process of walking them through it might make you come up with a solution yourself. "],
["it-works-again.html", "11 It works again?", " 11 It works again? A cryptic stack overflow post fixed it? You made some random changes? https://wyncode.co/funniest-computer-programming-memes/ Take the time to figure out why these fixes work and try making a note what the solution was. Chances are you’ll break it again or run into the same error later in your code. "],
["use-git.html", "12 Use Git!", " 12 Use Git! Create a bugfix branch (or two or three if you try more complex approaches) You can easily get back to your starting point Consider keeping the branch with a failed attempt it might be close to the truth You don’t create new problems by forgetting to change something back in some remote part of the code that turned out to not work https://xkcd.com/1739/ You can keep track of what you already tried If an attempt almost got you there and you discover the one thing that was missing three hours later you can easily recreate that “95% good” state When you fixed the problem you can analyse the solution by looking at what exactly was changed "],
["getting-frustrated.html", "13 Getting frustrated?", " 13 Getting frustrated? Are you trying the same thing for the third time? You can’t remember which of the 20 open tabs you have already tried? Hitting your computer or cursing at the screen? Randomly changing stuff? Copy and paste cryptic code snippets from stack overflow? Take a deep breath! Remind yourself that computers are completely rational. Noone is out there to get you! There is a logical reason! It didn’t just magically break! https://www.freecodecamp.org/news/content/images/2019/07/that-string-secretly-became-a-number.jpeg Be determined to understand the problem. Embrace the challenge and the learning experience! Take a break! https://www.monkeyuser.com/2018/debugging/ "],
["resources.html", "14 Resources", " 14 Resources 14.0.1 Debugging with RStudio - Jonathan McPherson https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio 14.0.2 Advanced R - Hadley Wickham (Chapter 22 Debugging) https://adv-r.hadley.nz/debugging.html 14.0.3 What They Forgot to Teach You About R - Jennifer Bryan, Jim Hester https://rstats.wtf/debugging-r-code.html 14.0.4 Toy examples to test your debugging skills rstd.io/wtf-debugging "]
]
